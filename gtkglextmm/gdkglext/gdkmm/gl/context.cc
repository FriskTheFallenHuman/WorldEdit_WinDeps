// Generated by gtkmmproc -- DO NOT MODIFY!

#include <Windows.h>

#include <gdkmm/gl/context.h>
#include <gdkmm/gl/private/context_p.h>

// -*- C++ -*-
/* gdkglextmm - C++ Wrapper for GdkGLExt
 * Copyright (C) 2002-2003  Naofumi Yasufuku
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA.
 */

#include <gdk/gdkglcontext.h>

namespace Gdk
{
  namespace GL
  {

    Context::Context(const Glib::RefPtr<const Drawable>& gldrawable,
                     const Glib::RefPtr<const Context>& share_list,
                     bool direct,
                     int render_type)
      : Glib::Object(reinterpret_cast<GObject*>(
          gdk_gl_context_new(const_cast<GdkGLDrawable*>(Glib::unwrap<Drawable>(gldrawable)),
                             const_cast<GdkGLContext*>(Glib::unwrap<Context>(share_list)),
                             direct,
                             render_type)))
    {}

    Context::Context(const Glib::RefPtr<const Drawable>& gldrawable,
                     bool direct,
                     int render_type)
      : Glib::Object(reinterpret_cast<GObject*>(
          gdk_gl_context_new(const_cast<GdkGLDrawable*>(Glib::unwrap<Drawable>(gldrawable)),
                             0,
                             direct,
                             render_type)))
    {}

    Glib::RefPtr<Context> Context::create(const Glib::RefPtr<const Drawable>& gldrawable,
                                          const Glib::RefPtr<const Context>& share_list,
                                          bool direct,
                                          int render_type)
    {
      return Glib::RefPtr<Context>(
        new Context(gldrawable, share_list, direct, render_type));
    }

    Glib::RefPtr<Context> Context::create(const Glib::RefPtr<const Drawable>& gldrawable,
                                          bool direct,
                                          int render_type)
    {
      return Glib::RefPtr<Context>(
        new Context(gldrawable, direct, render_type));
    }

    bool Context::copy(const Glib::RefPtr<const Context>& src,
                       unsigned long mask)
    {
      return gdk_gl_context_copy(gobj(),
                                 const_cast<GdkGLContext*>(Glib::unwrap<Context>(src)),
                                 mask);
    }

  } // namespace GL
} // namespace Gdk


namespace
{
} // anonymous namespace


namespace Glib
{

Glib::RefPtr<Gdk::GL::Context> wrap(GdkGLContext* object, bool take_copy)
{
  return Glib::RefPtr<Gdk::GL::Context>( dynamic_cast<Gdk::GL::Context*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gdk
{

namespace GL
{


/* The *_Class implementation: */

const Glib::Class& Context_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &Context_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(gdk_gl_context_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:
  }

  return *this;
}

void Context_Class::class_init_function(void* g_class, void* class_data)
{
  BaseClassType *const klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);

}


Glib::ObjectBase* Context_Class::wrap_new(GObject* object)
{
  return new Context((GdkGLContext*)object);
}


/* The implementation: */

GdkGLContext* Context::gobj_copy()
{
  reference();
  return gobj();
}

Context::Context(const Glib::ConstructParams& construct_params)
:
  Glib::Object(construct_params)
{}

Context::Context(GdkGLContext* castitem)
:
  Glib::Object((GObject*)(castitem))
{}

Context::~Context()
{}


Context::CppClassType Context::context_class_; // initialize static member

GType Context::get_type()
{
  return context_class_.init().get_type();
}

GType Context::get_base_type()
{
  return gdk_gl_context_get_type();
}


Glib::RefPtr<Drawable> Context::get_gl_drawable()
{

  Glib::RefPtr<Drawable> retvalue = Glib::wrap((GdkGLDrawable*)(gdk_gl_context_get_gl_drawable(gobj())));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<const Drawable> Context::get_gl_drawable() const
{

  Glib::RefPtr<const Drawable> retvalue = Glib::wrap((GdkGLDrawable*)(gdk_gl_context_get_gl_drawable(const_cast<GdkGLContext*>(gobj()))));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<Config> Context::get_gl_config()
{

  Glib::RefPtr<Config> retvalue = Glib::wrap((GdkGLConfig*)(gdk_gl_context_get_gl_config(gobj())));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<const Config> Context::get_gl_config() const
{

  Glib::RefPtr<const Config> retvalue = Glib::wrap((GdkGLConfig*)(gdk_gl_context_get_gl_config(const_cast<GdkGLContext*>(gobj()))));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<Context> Context::get_share_list()
{

  Glib::RefPtr<Context> retvalue = Glib::wrap((GdkGLContext*)(gdk_gl_context_get_share_list(gobj())));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<const Context> Context::get_share_list() const
{

  Glib::RefPtr<const Context> retvalue = Glib::wrap((GdkGLContext*)(gdk_gl_context_get_share_list(const_cast<GdkGLContext*>(gobj()))));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

bool Context::is_direct() const
{
  return gdk_gl_context_is_direct(const_cast<GdkGLContext*>(gobj()));
}

int Context::get_render_type() const
{
  return gdk_gl_context_get_render_type(const_cast<GdkGLContext*>(gobj()));
}

Glib::RefPtr<Context> Context::get_current()
{

  Glib::RefPtr<Context> retvalue = Glib::wrap((GdkGLContext*)(gdk_gl_context_get_current()));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}


} // namespace GL

} // namespace Gdk


