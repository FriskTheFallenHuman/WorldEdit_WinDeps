// Generated by gtkmmproc -- DO NOT MODIFY!

#include <gdkmm/gl/config.h>
#include <gdkmm/gl/private/config_p.h>

// -*- C++ -*-
/* gdkglextmm - C++ Wrapper for GdkGLExt
 * Copyright (C) 2002-2003  Naofumi Yasufuku
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA.
 */

#include <gdk/gdkglenumtypes.h>
#include <gdk/gdkglconfig.h>

namespace Gdk
{
  namespace GL
  {

    Config::Config(const int* attrib_list)
      : Glib::Object(reinterpret_cast<GObject*>(
          gdk_gl_config_new(attrib_list)))
    {}

#ifdef GDKGLEXTMM_MULTIHEAD_SUPPORT
    Config::Config(const Glib::RefPtr<const Gdk::Screen>& screen,
                   const int* attrib_list)
      : Glib::Object(reinterpret_cast<GObject*>(
          gdk_gl_config_new_for_screen(const_cast<GdkScreen*>(Glib::unwrap<Gdk::Screen>(screen)),
                                       attrib_list)))
    {}
#endif // GDKGLEXTMM_MULTIHEAD_SUPPORT

    Config::Config(ConfigMode mode)
      : Glib::Object(reinterpret_cast<GObject*>(
          gdk_gl_config_new_by_mode((GdkGLConfigMode)(mode))))
    {}

#ifdef GDKGLEXTMM_MULTIHEAD_SUPPORT
    Config::Config(const Glib::RefPtr<const Gdk::Screen>& screen,
                   ConfigMode mode)
      : Glib::Object(reinterpret_cast<GObject*>(
          gdk_gl_config_new_by_mode_for_screen(const_cast<GdkScreen*>(Glib::unwrap<Gdk::Screen>(screen)),
                                               (GdkGLConfigMode)(mode))))
    {}
#endif // GDKGLEXTMM_MULTIHEAD_SUPPORT

    Glib::RefPtr<Config> Config::create(const int* attrib_list)
    {
      return Glib::wrap(gdk_gl_config_new(attrib_list));
    }

#ifdef GDKGLEXTMM_MULTIHEAD_SUPPORT
    Glib::RefPtr<Config> Config::create(const Glib::RefPtr<const Gdk::Screen>& screen,
                                        const int* attrib_list)
    {
      return Glib::wrap(
        gdk_gl_config_new_for_screen(const_cast<GdkScreen*>(Glib::unwrap<Gdk::Screen>(screen)),
                                     attrib_list));
    }
#endif // GDKGLEXTMM_MULTIHEAD_SUPPORT

    Glib::RefPtr<Config> Config::create(ConfigMode mode)
    {
      return Glib::wrap(gdk_gl_config_new_by_mode((GdkGLConfigMode)(mode)));
    }

#ifdef GDKGLEXTMM_MULTIHEAD_SUPPORT
    Glib::RefPtr<Config> Config::create(const Glib::RefPtr<const Gdk::Screen>& screen,
                                        ConfigMode mode)
    {
      return Glib::wrap(
        gdk_gl_config_new_by_mode_for_screen(const_cast<GdkScreen*>(Glib::unwrap<Gdk::Screen>(screen)),
                                             (GdkGLConfigMode)(mode)));
    }
#endif // GDKGLEXTMM_MULTIHEAD_SUPPORT

#ifdef GDKGLEXTMM_MULTIHEAD_SUPPORT
    Glib::RefPtr<Gdk::Screen> Config::get_screen()
    {
      Glib::RefPtr<Gdk::Screen> retvalue =
        Glib::wrap(gdk_gl_config_get_screen(gobj()));

      if (retvalue)
        retvalue->reference(); //The function does not do a ref for us.

      return retvalue;
    }
#endif // GDKGLEXTMM_MULTIHEAD_SUPPORT

#ifdef GDKGLEXTMM_MULTIHEAD_SUPPORT
    Glib::RefPtr<const Gdk::Screen> Config::get_screen() const
    {
      Glib::RefPtr<const Gdk::Screen> retvalue =
        Glib::wrap(gdk_gl_config_get_screen(const_cast<GdkGLConfig*>(gobj())));

      if (retvalue)
        retvalue->reference(); //The function does not do a ref for us.

      return retvalue;
    }
#endif // GDKGLEXTMM_MULTIHEAD_SUPPORT

  } // namespace GL
} // namespace Gdk


namespace
{
} // anonymous namespace

// static
GType Glib::Value<Gdk::GL::ConfigMode>::value_type()
{
  return gdk_gl_config_mode_get_type();
}


namespace Glib
{

Glib::RefPtr<Gdk::GL::Config> wrap(GdkGLConfig* object, bool take_copy)
{
  return Glib::RefPtr<Gdk::GL::Config>( dynamic_cast<Gdk::GL::Config*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gdk
{

namespace GL
{


/* The *_Class implementation: */

const Glib::Class& Config_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &Config_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(gdk_gl_config_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:
  }

  return *this;
}

void Config_Class::class_init_function(void* g_class, void* class_data)
{
  BaseClassType *const klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);

}


Glib::ObjectBase* Config_Class::wrap_new(GObject* object)
{
  return new Config((GdkGLConfig*)object);
}


/* The implementation: */

GdkGLConfig* Config::gobj_copy()
{
  reference();
  return gobj();
}

Config::Config(const Glib::ConstructParams& construct_params)
:
  Glib::Object(construct_params)
{}

Config::Config(GdkGLConfig* castitem)
:
  Glib::Object((GObject*)(castitem))
{}

Config::~Config()
{}


Config::CppClassType Config::config_class_; // initialize static member

GType Config::get_type()
{
  return config_class_.init().get_type();
}

GType Config::get_base_type()
{
  return gdk_gl_config_get_type();
}


bool Config::get_attrib(int attribute, int& value) const
{
  return gdk_gl_config_get_attrib(const_cast<GdkGLConfig*>(gobj()), attribute, &value);
}

Glib::RefPtr<Gdk::Colormap> Config::get_colormap()
{

  Glib::RefPtr<Gdk::Colormap> retvalue = Glib::wrap(gdk_gl_config_get_colormap(gobj()));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<const Gdk::Colormap> Config::get_colormap() const
{

  Glib::RefPtr<const Gdk::Colormap> retvalue = Glib::wrap(gdk_gl_config_get_colormap(const_cast<GdkGLConfig*>(gobj())));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<Gdk::Visual> Config::get_visual()
{

  Glib::RefPtr<Gdk::Visual> retvalue = Glib::wrap(gdk_gl_config_get_visual(gobj()));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<const Gdk::Visual> Config::get_visual() const
{

  Glib::RefPtr<const Gdk::Visual> retvalue = Glib::wrap(gdk_gl_config_get_visual(const_cast<GdkGLConfig*>(gobj())));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

int Config::get_depth() const
{
  return gdk_gl_config_get_depth(const_cast<GdkGLConfig*>(gobj()));
}

int Config::get_layer_plane() const
{
  return gdk_gl_config_get_layer_plane(const_cast<GdkGLConfig*>(gobj()));
}

int Config::get_n_aux_buffers() const
{
  return gdk_gl_config_get_n_aux_buffers(const_cast<GdkGLConfig*>(gobj()));
}

int Config::get_n_sample_buffers() const
{
  return gdk_gl_config_get_n_sample_buffers(const_cast<GdkGLConfig*>(gobj()));
}

bool Config::is_rgba() const
{
  return gdk_gl_config_is_rgba(const_cast<GdkGLConfig*>(gobj()));
}

bool Config::is_double_buffered() const
{
  return gdk_gl_config_is_double_buffered(const_cast<GdkGLConfig*>(gobj()));
}

bool Config::is_stereo() const
{
  return gdk_gl_config_is_stereo(const_cast<GdkGLConfig*>(gobj()));
}

bool Config::has_alpha() const
{
  return gdk_gl_config_has_alpha(const_cast<GdkGLConfig*>(gobj()));
}

bool Config::has_depth_buffer() const
{
  return gdk_gl_config_has_depth_buffer(const_cast<GdkGLConfig*>(gobj()));
}

bool Config::has_stencil_buffer() const
{
  return gdk_gl_config_has_stencil_buffer(const_cast<GdkGLConfig*>(gobj()));
}

bool Config::has_accum_buffer() const
{
  return gdk_gl_config_has_accum_buffer(const_cast<GdkGLConfig*>(gobj()));
}


} // namespace GL

} // namespace Gdk


